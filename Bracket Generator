'''
Author: Nicolas Sigler
Date: 10/29/2025
Version: 1.0
Purpose: Creates tournament brackets from teams with similar ELO ratings playing
against each other. Supports single elimination, double elimination, and round robin formats.
Takes output directly from Team Creation.py script.
Alternatively can take manual input in a similar format.
'''
import math
import json
import sys


def parse_team_output(output_text):
    """Parse team information from Team Creation script output."""
    teams = []
    lines = output_text.strip().split('\n')

    current_team = None
    for line in lines:
        line = line.strip()

        # Look for team headers like "Team 1: Player1, Player2"
        if line.startswith('Team ') and ':' in line:
            team_num = line.split(':')[0].strip()
            current_team = {'name': team_num, 'players': []}

        # Look for average ELO lines like "Average ELO: 1234.5 (~Gold 2)"
        elif line.startswith('Average ELO:') and current_team is not None:
            try:
                # Extract the numeric ELO value
                elo_part = line.split(':')[1].split('(')[0].strip()
                elo = float(elo_part)
                current_team['elo'] = elo
                teams.append(current_team)
                current_team = None
            except (ValueError, IndexError):
                continue

    return teams


def get_team_input_method():
    """Ask user how they want to input teams."""
    print("\n" + "=" * 80)
    print("TOURNAMENT BRACKET GENERATOR")
    print("=" * 80)
    print("\nHow would you like to input teams?")
    print("  1. Paste output from Team Creation script")
    print("  2. Manual entry (Team Name, ELO)")

    while True:
        choice = input("Choose input method (1-2): ").strip()
        if choice in ['1', '2']:
            return choice
        print("Please enter 1 or 2.")


def get_teams_from_paste():
    """Get teams by pasting Team Creation script output."""
    print("\n" + "=" * 80)
    print("Paste the output from Team Creation script below.")
    print("Include the 'TEAMS' section with team names and average ELOs.")
    print("Press Enter, then type 'DONE' on a new line, then press Enter again when finished.")
    print("=" * 80 + "\n")

    lines = []
    while True:
        line = input()
        if line.strip().upper() == 'DONE':
            break
        lines.append(line)

    output_text = '\n'.join(lines)
    teams = parse_team_output(output_text)

    if not teams:
        print("\nNo teams found in pasted text. Please check the format.")
        return None

    print(f"\nâœ“ Found {len(teams)} teams:")
    for team in teams:
        print(f"  - {team['name']}: ELO {team['elo']:.1f}")

    confirm = input("\nAre these teams correct? (y/n): ").strip().lower()
    if confirm != 'y':
        return None

    return teams


def get_teams_manual():
    """Get team information from manual user input."""
    teams = []

    print("\nEnter teams (format: 'Team Name, Average ELO')")
    print("Examples: 'Team Alpha, 1500' or 'Team Beta, 1200'")
    print("Press Enter with empty input when done.\n")

    while True:
        team_input = input("Team: ").strip()
        if not team_input:
            break

        try:
            name, elo_str = team_input.rsplit(',', 1)
            name = name.strip()
            elo = float(elo_str.strip())
            teams.append({'name': name, 'elo': elo})
        except ValueError:
            print("Invalid format. Use 'Team Name, ELO'")
            continue

    return teams


def select_bracket_type():
    """Let user select tournament format."""
    print("\nTournament Format:")
    print("  1. Single Elimination")
    print("  2. Double Elimination")
    print("  3. Round Robin")

    while True:
        choice = input("Choose format (1-3): ").strip()
        if choice in ['1', '2', '3']:
            return choice
        print("Please enter a number between 1 and 3.")


def create_balanced_matchups(teams):
    """
    Create matchups pairing teams with similar ELO ratings.
    Uses a seeding system where closest-ranked teams play each other.
    """
    # Sort teams by ELO (highest to lowest)
    sorted_teams = sorted(teams, key=lambda x: x['elo'], reverse=True)

    # Assign seeds
    for i, team in enumerate(sorted_teams, 1):
        team['seed'] = i

    return sorted_teams


def pad_to_power_of_two(teams):
    """Pad team list to nearest power of 2 with byes."""
    n = len(teams)
    next_power = 2 ** math.ceil(math.log2(n))

    byes_needed = next_power - n

    # Add bye placeholders
    for i in range(byes_needed):
        teams.append({'name': 'BYE', 'elo': 0, 'seed': n + i + 1, 'is_bye': True})

    return teams, byes_needed


def create_single_elimination_bracket(teams):
    """
    Create single elimination bracket with balanced matchups.
    Higher seeds play lower seeds (1 vs n, 2 vs n-1, etc.)
    """
    sorted_teams = create_balanced_matchups(teams)
    n = len(sorted_teams)

    # Pad to power of 2
    sorted_teams, byes = pad_to_power_of_two(sorted_teams)
    total_teams = len(sorted_teams)

    # Create matchups: seed 1 vs last seed, seed 2 vs second-to-last, etc.
    matchups = []
    for i in range(total_teams // 2):
        team1 = sorted_teams[i]
        team2 = sorted_teams[total_teams - 1 - i]
        matchups.append((team1, team2))

    return matchups, sorted_teams


def create_double_elimination_bracket(teams):
    """Create double elimination bracket (winners and losers brackets)."""
    matchups, sorted_teams = create_single_elimination_bracket(teams)
    return matchups, sorted_teams


def create_round_robin_matchups(teams):
    """Create round robin where every team plays every other team once."""
    sorted_teams = create_balanced_matchups(teams)
    matchups = []

    for i in range(len(sorted_teams)):
        for j in range(i + 1, len(sorted_teams)):
            matchups.append((sorted_teams[i], sorted_teams[j]))

    return matchups, sorted_teams


def display_single_elimination_bracket(matchups, teams):
    """Display single elimination bracket."""
    print("\n" + "=" * 80)
    print("SINGLE ELIMINATION BRACKET")
    print("=" * 80)

    total_teams = len(teams)
    total_rounds = int(math.log2(total_teams))

    print(f"\nTotal Teams: {total_teams}")
    print(f"Total Rounds: {total_rounds}")
    print(f"Seeds assigned by ELO (highest = seed 1)")

    # Round 1
    print(f"\n{'ROUND 1':-^80}")
    for i, (team1, team2) in enumerate(matchups, 1):
        elo_diff = abs(team1['elo'] - team2['elo'])

        if team1.get('is_bye') or team2.get('is_bye'):
            active_team = team1 if not team1.get('is_bye') else team2
            print(f"\nMatch {i}:")
            print(f"  Seed {active_team['seed']}: {active_team['name']} (ELO: {active_team['elo']:.1f})")
            print(f"  >>> BYE - {active_team['name']} advances automatically")
        else:
            print(f"\nMatch {i}:")
            print(f"  Seed {team1['seed']}: {team1['name']} (ELO: {team1['elo']:.1f})")
            print(f"     vs")
            print(f"  Seed {team2['seed']}: {team2['name']} (ELO: {team2['elo']:.1f})")
            print(f"  ELO Difference: {elo_diff:.1f}")

    # Show bracket structure for subsequent rounds
    winners_count = len(matchups)
    for round_num in range(2, total_rounds + 1):
        winners_count = winners_count // 2
        print(f"\n{'ROUND ' + str(round_num):-^80}")
        print(f"{winners_count} matches (winners from Round {round_num - 1})")
        for i in range(1, winners_count + 1):
            print(
                f"  Match {i}: Winner of R{round_num - 1} Match {2 * i - 1} vs Winner of R{round_num - 1} Match {2 * i}")

    print(f"\n{'FINALS':-^80}")
    print("Winner of last 2 semifinals")


def display_double_elimination_bracket(matchups, teams):
    """Display double elimination bracket overview."""
    print("\n" + "=" * 80)
    print("DOUBLE ELIMINATION BRACKET")
    print("=" * 80)

    total_teams = len(teams)

    print(f"\nTotal Teams: {total_teams}")
    print(f"Format: Teams get eliminated after 2 losses")
    print(f"Seeds assigned by ELO (highest = seed 1)")

    # Winners Bracket Round 1
    print(f"\n{'WINNERS BRACKET - ROUND 1':-^80}")
    for i, (team1, team2) in enumerate(matchups, 1):
        elo_diff = abs(team1['elo'] - team2['elo'])

        if team1.get('is_bye') or team2.get('is_bye'):
            active_team = team1 if not team1.get('is_bye') else team2
            print(f"\nMatch W1-{i}:")
            print(f"  Seed {active_team['seed']}: {active_team['name']} (ELO: {active_team['elo']:.1f})")
            print(f"  >>> BYE - {active_team['name']} advances automatically")
        else:
            print(f"\nMatch W1-{i}:")
            print(f"  Seed {team1['seed']}: {team1['name']} (ELO: {team1['elo']:.1f})")
            print(f"     vs")
            print(f"  Seed {team2['seed']}: {team2['name']} (ELO: {team2['elo']:.1f})")
            print(f"  ELO Difference: {elo_diff:.1f}")
            print(f"  Loser drops to Losers Bracket")

    print(f"\n{'LOSERS BRACKET':-^80}")
    print("Losers from Winners Bracket compete here")
    print("One loss in Losers Bracket = elimination")

    print(f"\n{'GRAND FINALS':-^80}")
    print("Winners Bracket Champion vs Losers Bracket Champion")
    print("Losers Bracket Champion must win 2 series to claim title")


def display_round_robin_bracket(matchups, teams):
    """Display round robin schedule."""
    print("\n" + "=" * 80)
    print("ROUND ROBIN BRACKET")
    print("=" * 80)

    print(f"\nTotal Teams: {len(teams)}")
    print(f"Total Matches: {len(matchups)}")
    print(f"Format: Every team plays every other team once")
    print(f"Seeds assigned by ELO (for reference only)")

    # Display all teams
    print(f"\n{'TEAMS':-^80}")
    for team in teams:
        print(f"  Seed {team['seed']}: {team['name']} (ELO: {team['elo']:.1f})")

    # Display matchups
    print(f"\n{'ALL MATCHUPS':-^80}")
    for i, (team1, team2) in enumerate(matchups, 1):
        elo_diff = abs(team1['elo'] - team2['elo'])
        print(f"\nMatch {i}:")
        print(f"  Seed {team1['seed']}: {team1['name']} (ELO: {team1['elo']:.1f})")
        print(f"     vs")
        print(f"  Seed {team2['seed']}: {team2['name']} (ELO: {team2['elo']:.1f})")
        print(f"  ELO Difference: {elo_diff:.1f}")

    print(f"\n{'STANDINGS':-^80}")
    print("Track wins/losses to determine final rankings")


def export_bracket(bracket_type, matchups, teams, filename="tournament_bracket.json"):
    """Export bracket to JSON file."""
    data = {
        'bracket_type': bracket_type,
        'teams': teams,
        'matchups': [(t1, t2) for t1, t2 in matchups]
    }

    try:
        with open(filename, 'w') as f:
            json.dump(data, f, indent=2)
        print(f"\nBracket exported to {filename}")
    except Exception as e:
        print(f"\nError exporting bracket: {e}")


def main():
    # Get team input method
    input_method = get_team_input_method()

    teams = None
    if input_method == '1':
        teams = get_teams_from_paste()
        if teams is None:
            print("\nFalling back to manual entry...")
            teams = get_teams_manual()
    else:
        teams = get_teams_manual()

    if not teams or len(teams) < 2:
        print("\nNeed at least 2 teams to create a bracket!")
        return

    # Select bracket type
    bracket_type = select_bracket_type()

    # Create and display bracket
    if bracket_type == '1':
        matchups, sorted_teams = create_single_elimination_bracket(teams)
        display_single_elimination_bracket(matchups, sorted_teams)
    elif bracket_type == '2':
        matchups, sorted_teams = create_double_elimination_bracket(teams)
        display_double_elimination_bracket(matchups, sorted_teams)
    else:  # bracket_type == '3'
        matchups, sorted_teams = create_round_robin_matchups(teams)
        display_round_robin_bracket(matchups, sorted_teams)

    # Ask if user wants to export
    export = input("\nExport bracket to JSON file? (y/n): ").strip().lower()
    if export == 'y':
        bracket_names = {
            '1': 'single_elimination',
            '2': 'double_elimination',
            '3': 'round_robin'
        }
        export_bracket(bracket_names[bracket_type], matchups, sorted_teams)

    print("\n" + "=" * 80)


if __name__ == "__main__":
    main()
